def getAndroidTestCoverageFiles() {
	FileCollection androidTestCoverageFiles = fileTree("$buildDir/outputs/code-coverage/connected/flavors") {
		include "**/*.ec"
	}
	return androidTestCoverageFiles
}

task jacocoMergedTestReport(type: JacocoReport) {
	FileCollection unitTestCoverageFile = files("$buildDir/jacoco/testEnvUsDebugUnitTest.exec")

	FileCollection coverageFiles = getAndroidTestCoverageFiles() + unitTestCoverageFile

	inputs.files(coverageFiles)
	outputs.dir("$buildDir/reports/jacoco/jacocoMergedTestReport/html")

	setSourceDirectories(files(["$buildDir/../src/main/java/com"]))
	setClassDirectories(fileTree(
			dir: "$buildDir/intermediates/classes/envUs/debug/com",
			excludes: ['**/R*.class']))

	// this would only be a merged report if more files were defined here
	// for now it's just one maybe once we get stable UI test

	setExecutionData(coverageFiles)

	reports {
		xml.enabled true
		csv.enabled false
		html.enabled true
	}
}

task runUnitTests {
	dependsOn {
		[
				clean,
				testEnvUsDebugUnitTest
		]
	}
	mustRunAfter {
		[
				clean
		]
	}
	doLast {
		println "Unit tests run in central app"
	}
}

task buildAllBuilds {
	dependsOn {
		[
				runUnitTests,
				project(':app').tasks.findAll { task ->
					task.name.startsWith("assemble") &&
							shouldBuildForBuildType(task) &&
							shouldBuildBranchForInput(task)
				}
		]
	}
	mustRunAfter {
		[
				runUnitTests
		]
	}
	doLast {
		println "All builds have been built"
	}
}


def shouldBuildForBuildType(task) {
	if (!project.hasProperty("buildtype")) {
		return task.name.contains("Release")
	}
	def buildTypes = buildtype.split(',')
	return buildTypes.any { buildType ->
		task.name.contains(buildType.capitalize())
	}
}

// configure the mapping artifacts, namely adding the renamed file to the artifact,
// only adding those of environments in the environment variable
// Renaming e.g.: (envUs/release/)mapping.txt --> mapping-us.txt
task configureMappingArtifacts() {
	dependsOn {
		buildAllBuilds
	}
	mustRunAfter {
		buildAllBuilds
	}
	doLast {
		def fromPath = "${buildDir}${File.separator}outputs${File.separator}mapping"
		fileTree(fromPath).include('**/mapping.txt').files.each { each ->
			def newName = each.name.take(each.name.lastIndexOf('.')) + '-' + each.parentFile.parentFile.name.toLowerCase() + '-' + each.parentFile.name.toLowerCase() + '.txt'
			newName = newName.replaceAll('mapping-env', 'mapping-')
			each.renameTo("${fromPath}${File.separator}${newName}")
		}
	}
}

// configure the apk artifacts, namely adding the renamed file to the artifact,
// only adding those of environments in the environment variable 
// Renaming e.g.: app-envUs-release.apk --> app-us-release.apk
task configureApkArtifacts() {
	dependsOn {
		[
				buildAllBuilds
		]
	}
	mustRunAfter {
		[
				buildAllBuilds
		]
	}
	doLast {
		def fromPath = "${buildDir}${File.separator}outputs${File.separator}apk"
		fileTree(fromPath).include('**/**.apk').files.each { each ->
			def newName = each.name.toLowerCase()
			newName = newName.replaceAll('app-env', 'app-')
			each.renameTo("${fromPath}${File.separator}${newName}")
		}
	}
}


static def gitBranch() {
	def branch = ""
	def process = "git rev-parse --abbrev-ref HEAD".execute()
	process.in.eachLine { line -> branch = line }
	process.err.eachLine { line -> println line }
	process.waitFor()
	branch
}

static def shouldBuildBranchForInput(task) {
	String branch = getBranch()
	if (branch == "master" || branch == 'refs/heads/master') {
		return true
	}
	println branch
	// this needs to match the app's environment build flavor dimension
	def environments = "us,ca,uk,de".split(',')
	boolean foundMatchingEnvInBranchName = environments.any { env ->
		if (task == null) {
			branch.contains("/" + env + "/")
		}
		else {
			task.name.contains("Env" + env.capitalize()) && branch.contains("/" + env + "/")
		}
	}
	return foundMatchingEnvInBranchName
}

static String getBranch() {
	def branch = gitBranch()
	if (branch == "HEAD") {
		branch = System.getenv("BRANCH_NAME")
	}
	branch
}

task shouldBuildForBranch() {
	doLast {
		boolean foundMatchingEnvInBranchName = shouldBuildBranchForInput(null)

		if (!foundMatchingEnvInBranchName) {
			throw new GradleException('No matching environment found in branch name environment ' +
					'branch was: ' + getBranch())
		}
	}
}